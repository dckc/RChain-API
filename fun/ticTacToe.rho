new ticTacToe, stderr(`rho:io:stderr`) in {
  new xo in {
    ticTacToe!(*xo) | for (@(X, O) <- xo) {
      // Queue a whole bunch of moves
      for (@"go", _, where <- @X) { where!(0, 0) } |
      for (@"go", _, where <- @X) { where!(1, 0) } |
      for (@"go", _, where <- @X) { where!(-1, 0) } |
      for (@"go", _, where <- @X) { where!(0, 1) } |
      for (@"go", _, where <- @X) { where!(1, 1) } |
      for (@"go", _, where <- @X) { where!(-1, 1) } |

      for (@"BadMove", @why <= @X) {
        stderr!(["X bad move:", why])
      }
      |
      for (@"go", _, where <- @O) { where!(0, 1) } |
      for (@"go", _, where <- @O) { where!(1, 1) } |
      for (@"go", _, where <- @O) { where!(-1, 1) } |
      for (@"go", _, where <- @O) { where!(0, -1) } |
      for (@"go", _, where <- @O) { where!(1, -1) } |
      for (@"go", _, where <- @O) { where!(-1, -1) } |

      for (@"BadMove", @why <= @O) {
        stderr!(["O bad move:", why])
      }
    }
  }
  |
  contract ticTacToe(return) = {
    new boardCh, goX, goO in {
      return!((*goX, *goO)) |
      new turn in {
        new startCh, b0Ch in {
          stderr!("X starts") |
          b0Ch!({"X": Set(), "O": Set()}) | for (@b0 <- b0Ch) {
            goX!("go", b0, *startCh) | for (@x, @y <- startCh) {
              turn!(b0, *goX, "X", (x, y))
            }
          }
        }
        |
        // @board: Map[Side, Set[(Coord, Coord)]] where Coord between -1 and 1
        contract turn(@board, sideCh, @side, @(x, y)) = {
          stderr!(["turn:", side, (x, y), board]) |
          new redo, play in {
            if (x < -1 or y < -1 or x > 1 or y > 1) {
              sideCh!("BadMove", "out of bounds") |
              redo!(Nil)
            } else {
              if (board.get("X").union(board.get("O")).contains((x, y))) {
                sideCh!("BadMove", "space already occupied") |
                redo!(Nil)
              } else {
                play!(side, x, y)
              }
            }
            |
            contract redo(_) = {
              new nextCh in {
                sideCh!("go", board, *nextCh) | for (@x, @y <- nextCh) {
                  turn!(board, *sideCh, side, (x, y))
                }
              }
            }
            |
            contract play(@side, @x, @y) = {
              new nextBoardCh, nextSideCh, nextMove in {
                nextBoardCh!(board.set(side, board.get(side).add((x, y)))) |
                // TODO: determine winner
                match side {
                  "X" => nextSideCh!(*goO, "O")
                  "O" => nextSideCh!(*goX, "X")
                }
                |
                for (nextGo, @nextSide <- nextSideCh; @nextBoard <- nextBoardCh) {
                  if (board.get("X").union(board.get("O")).size() >= 9) {
                    stderr!("CATS game!") |
                    goX!("CATS!") | goO!("CATS!")
                  } else {
                    stderr!([nextSide, "'s turn. board:", nextBoard]) |
                    nextGo!("go", nextBoard, *nextMove) | for (@x, @y <- nextMove) {
                      turn!(nextBoard, *nextGo, nextSide, (x, y))
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
