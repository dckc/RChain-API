/**
 * Flowtype definitions for CasperMessage
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.10.0
 */

import * as $protobuf from "protobufjs";
declare var coop: typeof npm$namespace$coop;

declare var npm$namespace$coop: {|
  rchain: typeof npm$namespace$coop$rchain
|};

declare var npm$namespace$coop$rchain: {|
  casper: typeof npm$namespace$coop$rchain$casper
|};

declare var npm$namespace$coop$rchain$casper: {|
  protocol: typeof npm$namespace$coop$rchain$casper$protocol
|};

declare var npm$namespace$coop$rchain$casper$protocol: {|
  HasBlockRequest: typeof coop$rchain$casper$protocol$HasBlockRequest,
  HasBlock: typeof coop$rchain$casper$protocol$HasBlock,
  BlockRequest: typeof coop$rchain$casper$protocol$BlockRequest,
  ForkChoiceTipRequest: typeof coop$rchain$casper$protocol$ForkChoiceTipRequest,
  ApprovedBlockCandidate: typeof coop$rchain$casper$protocol$ApprovedBlockCandidate,
  UnapprovedBlock: typeof coop$rchain$casper$protocol$UnapprovedBlock,
  Signature: typeof coop$rchain$casper$protocol$Signature,
  BlockApproval: typeof coop$rchain$casper$protocol$BlockApproval,
  ApprovedBlock: typeof coop$rchain$casper$protocol$ApprovedBlock,
  ApprovedBlockRequest: typeof coop$rchain$casper$protocol$ApprovedBlockRequest,
  NoApprovedBlockAvailable: typeof coop$rchain$casper$protocol$NoApprovedBlockAvailable,
  BlockMessage: typeof coop$rchain$casper$protocol$BlockMessage,
  BlockMetadataInternal: typeof coop$rchain$casper$protocol$BlockMetadataInternal,
  Header: typeof coop$rchain$casper$protocol$Header,
  DeployData: typeof coop$rchain$casper$protocol$DeployData,
  ProcessedDeploy: typeof coop$rchain$casper$protocol$ProcessedDeploy,
  Body: typeof coop$rchain$casper$protocol$Body,
  Justification: typeof coop$rchain$casper$protocol$Justification,
  RChainState: typeof coop$rchain$casper$protocol$RChainState,
  Event: typeof coop$rchain$casper$protocol$Event,
  ProduceEvent: typeof coop$rchain$casper$protocol$ProduceEvent,
  ConsumeEvent: typeof coop$rchain$casper$protocol$ConsumeEvent,
  CommEvent: typeof coop$rchain$casper$protocol$CommEvent,
  Bond: typeof coop$rchain$casper$protocol$Bond
|};
declare interface coop$rchain$casper$protocol$IHasBlockRequest {
  hash?: Uint8Array | null;
}

declare class coop$rchain$casper$protocol$HasBlockRequest
  mixins coop$rchain$casper$protocol$IHasBlockRequest {
  constructor(properties?: coop$rchain$casper$protocol$IHasBlockRequest): this;
  hash: Uint8Array;
  static create(
    properties?: coop$rchain$casper$protocol$IHasBlockRequest
  ): coop$rchain$casper$protocol$HasBlockRequest;
  static encode(
    message: coop$rchain$casper$protocol$IHasBlockRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IHasBlockRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$HasBlockRequest;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$HasBlockRequest;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): coop$rchain$casper$protocol$HasBlockRequest;
  static toObject(
    message: coop$rchain$casper$protocol$HasBlockRequest,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface coop$rchain$casper$protocol$IHasBlock {
  hash?: Uint8Array | null;
}

declare class coop$rchain$casper$protocol$HasBlock
  mixins coop$rchain$casper$protocol$IHasBlock {
  constructor(properties?: coop$rchain$casper$protocol$IHasBlock): this;
  hash: Uint8Array;
  static create(
    properties?: coop$rchain$casper$protocol$IHasBlock
  ): coop$rchain$casper$protocol$HasBlock;
  static encode(
    message: coop$rchain$casper$protocol$IHasBlock,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IHasBlock,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$HasBlock;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$HasBlock;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): coop$rchain$casper$protocol$HasBlock;
  static toObject(
    message: coop$rchain$casper$protocol$HasBlock,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface coop$rchain$casper$protocol$IBlockRequest {
  hash?: Uint8Array | null;
}

declare class coop$rchain$casper$protocol$BlockRequest
  mixins coop$rchain$casper$protocol$IBlockRequest {
  constructor(properties?: coop$rchain$casper$protocol$IBlockRequest): this;
  hash: Uint8Array;
  static create(
    properties?: coop$rchain$casper$protocol$IBlockRequest
  ): coop$rchain$casper$protocol$BlockRequest;
  static encode(
    message: coop$rchain$casper$protocol$IBlockRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IBlockRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$BlockRequest;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$BlockRequest;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): coop$rchain$casper$protocol$BlockRequest;
  static toObject(
    message: coop$rchain$casper$protocol$BlockRequest,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface coop$rchain$casper$protocol$IForkChoiceTipRequest {}

declare class coop$rchain$casper$protocol$ForkChoiceTipRequest
  mixins coop$rchain$casper$protocol$IForkChoiceTipRequest {
  constructor(
    properties?: coop$rchain$casper$protocol$IForkChoiceTipRequest
  ): this;
  static create(
    properties?: coop$rchain$casper$protocol$IForkChoiceTipRequest
  ): coop$rchain$casper$protocol$ForkChoiceTipRequest;
  static encode(
    message: coop$rchain$casper$protocol$IForkChoiceTipRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IForkChoiceTipRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$ForkChoiceTipRequest;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$ForkChoiceTipRequest;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): coop$rchain$casper$protocol$ForkChoiceTipRequest;
  static toObject(
    message: coop$rchain$casper$protocol$ForkChoiceTipRequest,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface coop$rchain$casper$protocol$IApprovedBlockCandidate {
  block?: coop$rchain$casper$protocol$IBlockMessage | null;
  requiredSigs?: number | null;
}

declare class coop$rchain$casper$protocol$ApprovedBlockCandidate
  mixins coop$rchain$casper$protocol$IApprovedBlockCandidate {
  constructor(
    properties?: coop$rchain$casper$protocol$IApprovedBlockCandidate
  ): this;
  block?: coop$rchain$casper$protocol$IBlockMessage | null;
  requiredSigs: number;
  static create(
    properties?: coop$rchain$casper$protocol$IApprovedBlockCandidate
  ): coop$rchain$casper$protocol$ApprovedBlockCandidate;
  static encode(
    message: coop$rchain$casper$protocol$IApprovedBlockCandidate,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IApprovedBlockCandidate,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$ApprovedBlockCandidate;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$ApprovedBlockCandidate;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): coop$rchain$casper$protocol$ApprovedBlockCandidate;
  static toObject(
    message: coop$rchain$casper$protocol$ApprovedBlockCandidate,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface coop$rchain$casper$protocol$IUnapprovedBlock {
  candidate?: coop$rchain$casper$protocol$IApprovedBlockCandidate | null;
  timestamp?: number | Long | null;
  duration?: number | Long | null;
}

declare class coop$rchain$casper$protocol$UnapprovedBlock
  mixins coop$rchain$casper$protocol$IUnapprovedBlock {
  constructor(properties?: coop$rchain$casper$protocol$IUnapprovedBlock): this;
  candidate?: coop$rchain$casper$protocol$IApprovedBlockCandidate | null;
  timestamp: number | Long;
  duration: number | Long;
  static create(
    properties?: coop$rchain$casper$protocol$IUnapprovedBlock
  ): coop$rchain$casper$protocol$UnapprovedBlock;
  static encode(
    message: coop$rchain$casper$protocol$IUnapprovedBlock,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IUnapprovedBlock,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$UnapprovedBlock;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$UnapprovedBlock;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): coop$rchain$casper$protocol$UnapprovedBlock;
  static toObject(
    message: coop$rchain$casper$protocol$UnapprovedBlock,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface coop$rchain$casper$protocol$ISignature {
  publicKey?: Uint8Array | null;
  algorithm?: string | null;
  sig?: Uint8Array | null;
}

declare class coop$rchain$casper$protocol$Signature
  mixins coop$rchain$casper$protocol$ISignature {
  constructor(properties?: coop$rchain$casper$protocol$ISignature): this;
  publicKey: Uint8Array;
  algorithm: string;
  sig: Uint8Array;
  static create(
    properties?: coop$rchain$casper$protocol$ISignature
  ): coop$rchain$casper$protocol$Signature;
  static encode(
    message: coop$rchain$casper$protocol$ISignature,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$ISignature,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$Signature;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$Signature;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): coop$rchain$casper$protocol$Signature;
  static toObject(
    message: coop$rchain$casper$protocol$Signature,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface coop$rchain$casper$protocol$IBlockApproval {
  candidate?: coop$rchain$casper$protocol$IApprovedBlockCandidate | null;
  sig?: coop$rchain$casper$protocol$ISignature | null;
}

declare class coop$rchain$casper$protocol$BlockApproval
  mixins coop$rchain$casper$protocol$IBlockApproval {
  constructor(properties?: coop$rchain$casper$protocol$IBlockApproval): this;
  candidate?: coop$rchain$casper$protocol$IApprovedBlockCandidate | null;
  sig?: coop$rchain$casper$protocol$ISignature | null;
  static create(
    properties?: coop$rchain$casper$protocol$IBlockApproval
  ): coop$rchain$casper$protocol$BlockApproval;
  static encode(
    message: coop$rchain$casper$protocol$IBlockApproval,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IBlockApproval,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$BlockApproval;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$BlockApproval;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): coop$rchain$casper$protocol$BlockApproval;
  static toObject(
    message: coop$rchain$casper$protocol$BlockApproval,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface coop$rchain$casper$protocol$IApprovedBlock {
  candidate?: coop$rchain$casper$protocol$IApprovedBlockCandidate | null;
  sigs?: coop$rchain$casper$protocol$ISignature[] | null;
}

declare class coop$rchain$casper$protocol$ApprovedBlock
  mixins coop$rchain$casper$protocol$IApprovedBlock {
  constructor(properties?: coop$rchain$casper$protocol$IApprovedBlock): this;
  candidate?: coop$rchain$casper$protocol$IApprovedBlockCandidate | null;
  sigs: coop$rchain$casper$protocol$ISignature[];
  static create(
    properties?: coop$rchain$casper$protocol$IApprovedBlock
  ): coop$rchain$casper$protocol$ApprovedBlock;
  static encode(
    message: coop$rchain$casper$protocol$IApprovedBlock,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IApprovedBlock,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$ApprovedBlock;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$ApprovedBlock;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): coop$rchain$casper$protocol$ApprovedBlock;
  static toObject(
    message: coop$rchain$casper$protocol$ApprovedBlock,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface coop$rchain$casper$protocol$IApprovedBlockRequest {
  identifier?: string | null;
}

declare class coop$rchain$casper$protocol$ApprovedBlockRequest
  mixins coop$rchain$casper$protocol$IApprovedBlockRequest {
  constructor(
    properties?: coop$rchain$casper$protocol$IApprovedBlockRequest
  ): this;
  identifier: string;
  static create(
    properties?: coop$rchain$casper$protocol$IApprovedBlockRequest
  ): coop$rchain$casper$protocol$ApprovedBlockRequest;
  static encode(
    message: coop$rchain$casper$protocol$IApprovedBlockRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IApprovedBlockRequest,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$ApprovedBlockRequest;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$ApprovedBlockRequest;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): coop$rchain$casper$protocol$ApprovedBlockRequest;
  static toObject(
    message: coop$rchain$casper$protocol$ApprovedBlockRequest,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface coop$rchain$casper$protocol$INoApprovedBlockAvailable {
  identifier?: string | null;
  nodeIdentifer?: string | null;
}

declare class coop$rchain$casper$protocol$NoApprovedBlockAvailable
  mixins coop$rchain$casper$protocol$INoApprovedBlockAvailable {
  constructor(
    properties?: coop$rchain$casper$protocol$INoApprovedBlockAvailable
  ): this;
  identifier: string;
  nodeIdentifer: string;
  static create(
    properties?: coop$rchain$casper$protocol$INoApprovedBlockAvailable
  ): coop$rchain$casper$protocol$NoApprovedBlockAvailable;
  static encode(
    message: coop$rchain$casper$protocol$INoApprovedBlockAvailable,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$INoApprovedBlockAvailable,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$NoApprovedBlockAvailable;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$NoApprovedBlockAvailable;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): coop$rchain$casper$protocol$NoApprovedBlockAvailable;
  static toObject(
    message: coop$rchain$casper$protocol$NoApprovedBlockAvailable,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface coop$rchain$casper$protocol$IBlockMessage {
  blockHash?: Uint8Array | null;
  header?: coop$rchain$casper$protocol$IHeader | null;
  body?: coop$rchain$casper$protocol$IBody | null;
  justifications?: coop$rchain$casper$protocol$IJustification[] | null;
  sender?: Uint8Array | null;
  seqNum?: number | null;
  sig?: Uint8Array | null;
  sigAlgorithm?: string | null;
  shardId?: string | null;
  extraBytes?: Uint8Array | null;
}

declare class coop$rchain$casper$protocol$BlockMessage
  mixins coop$rchain$casper$protocol$IBlockMessage {
  constructor(properties?: coop$rchain$casper$protocol$IBlockMessage): this;
  blockHash: Uint8Array;
  header?: coop$rchain$casper$protocol$IHeader | null;
  body?: coop$rchain$casper$protocol$IBody | null;
  justifications: coop$rchain$casper$protocol$IJustification[];
  sender: Uint8Array;
  seqNum: number;
  sig: Uint8Array;
  sigAlgorithm: string;
  shardId: string;
  extraBytes: Uint8Array;
  static create(
    properties?: coop$rchain$casper$protocol$IBlockMessage
  ): coop$rchain$casper$protocol$BlockMessage;
  static encode(
    message: coop$rchain$casper$protocol$IBlockMessage,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IBlockMessage,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$BlockMessage;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$BlockMessage;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): coop$rchain$casper$protocol$BlockMessage;
  static toObject(
    message: coop$rchain$casper$protocol$BlockMessage,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface coop$rchain$casper$protocol$IBlockMetadataInternal {
  blockHash?: Uint8Array | null;
  parents?: Uint8Array[] | null;
  sender?: Uint8Array | null;
  justifications?: coop$rchain$casper$protocol$IJustification[] | null;
  bonds?: coop$rchain$casper$protocol$IBond[] | null;
  blockNum?: number | Long | null;
  seqNum?: number | null;
  invalid?: boolean | null;
}

declare class coop$rchain$casper$protocol$BlockMetadataInternal
  mixins coop$rchain$casper$protocol$IBlockMetadataInternal {
  constructor(
    properties?: coop$rchain$casper$protocol$IBlockMetadataInternal
  ): this;
  blockHash: Uint8Array;
  parents: Uint8Array[];
  sender: Uint8Array;
  justifications: coop$rchain$casper$protocol$IJustification[];
  bonds: coop$rchain$casper$protocol$IBond[];
  blockNum: number | Long;
  seqNum: number;
  invalid: boolean;
  static create(
    properties?: coop$rchain$casper$protocol$IBlockMetadataInternal
  ): coop$rchain$casper$protocol$BlockMetadataInternal;
  static encode(
    message: coop$rchain$casper$protocol$IBlockMetadataInternal,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IBlockMetadataInternal,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$BlockMetadataInternal;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$BlockMetadataInternal;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): coop$rchain$casper$protocol$BlockMetadataInternal;
  static toObject(
    message: coop$rchain$casper$protocol$BlockMetadataInternal,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface coop$rchain$casper$protocol$IHeader {
  parentsHashList?: Uint8Array[] | null;
  postStateHash?: Uint8Array | null;
  deploysHash?: Uint8Array | null;
  timestamp?: number | Long | null;
  version?: number | Long | null;
  deployCount?: number | null;
  extraBytes?: Uint8Array | null;
}

declare class coop$rchain$casper$protocol$Header
  mixins coop$rchain$casper$protocol$IHeader {
  constructor(properties?: coop$rchain$casper$protocol$IHeader): this;
  parentsHashList: Uint8Array[];
  postStateHash: Uint8Array;
  deploysHash: Uint8Array;
  timestamp: number | Long;
  version: number | Long;
  deployCount: number;
  extraBytes: Uint8Array;
  static create(
    properties?: coop$rchain$casper$protocol$IHeader
  ): coop$rchain$casper$protocol$Header;
  static encode(
    message: coop$rchain$casper$protocol$IHeader,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IHeader,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$Header;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$Header;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): coop$rchain$casper$protocol$Header;
  static toObject(
    message: coop$rchain$casper$protocol$Header,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface coop$rchain$casper$protocol$IDeployData {
  deployer?: Uint8Array | null;
  term?: string | null;
  timestamp?: number | Long | null;
  sig?: Uint8Array | null;
  sigAlgorithm?: string | null;
  phloPrice?: number | Long | null;
  phloLimit?: number | Long | null;
  validAfterBlockNumber?: number | Long | null;
}

declare class coop$rchain$casper$protocol$DeployData
  mixins coop$rchain$casper$protocol$IDeployData {
  constructor(properties?: coop$rchain$casper$protocol$IDeployData): this;
  deployer: Uint8Array;
  term: string;
  timestamp: number | Long;
  sig: Uint8Array;
  sigAlgorithm: string;
  phloPrice: number | Long;
  phloLimit: number | Long;
  validAfterBlockNumber: number | Long;
  static create(
    properties?: coop$rchain$casper$protocol$IDeployData
  ): coop$rchain$casper$protocol$DeployData;
  static encode(
    message: coop$rchain$casper$protocol$IDeployData,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IDeployData,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$DeployData;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$DeployData;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): coop$rchain$casper$protocol$DeployData;
  static toObject(
    message: coop$rchain$casper$protocol$DeployData,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface coop$rchain$casper$protocol$IProcessedDeploy {
  deploy?: coop$rchain$casper$protocol$IDeployData | null;
  cost?: IPCost | null;
  deployLog?: coop$rchain$casper$protocol$IEvent[] | null;
  paymentLog?: coop$rchain$casper$protocol$IEvent[] | null;
  errored?: boolean | null;
}

declare class coop$rchain$casper$protocol$ProcessedDeploy
  mixins coop$rchain$casper$protocol$IProcessedDeploy {
  constructor(properties?: coop$rchain$casper$protocol$IProcessedDeploy): this;
  deploy?: coop$rchain$casper$protocol$IDeployData | null;
  cost?: IPCost | null;
  deployLog: coop$rchain$casper$protocol$IEvent[];
  paymentLog: coop$rchain$casper$protocol$IEvent[];
  errored: boolean;
  static create(
    properties?: coop$rchain$casper$protocol$IProcessedDeploy
  ): coop$rchain$casper$protocol$ProcessedDeploy;
  static encode(
    message: coop$rchain$casper$protocol$IProcessedDeploy,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IProcessedDeploy,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$ProcessedDeploy;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$ProcessedDeploy;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): coop$rchain$casper$protocol$ProcessedDeploy;
  static toObject(
    message: coop$rchain$casper$protocol$ProcessedDeploy,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface coop$rchain$casper$protocol$IBody {
  state?: coop$rchain$casper$protocol$IRChainState | null;
  deploys?: coop$rchain$casper$protocol$IProcessedDeploy[] | null;
  extraBytes?: Uint8Array | null;
}

declare class coop$rchain$casper$protocol$Body
  mixins coop$rchain$casper$protocol$IBody {
  constructor(properties?: coop$rchain$casper$protocol$IBody): this;
  state?: coop$rchain$casper$protocol$IRChainState | null;
  deploys: coop$rchain$casper$protocol$IProcessedDeploy[];
  extraBytes: Uint8Array;
  static create(
    properties?: coop$rchain$casper$protocol$IBody
  ): coop$rchain$casper$protocol$Body;
  static encode(
    message: coop$rchain$casper$protocol$IBody,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IBody,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$Body;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$Body;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): coop$rchain$casper$protocol$Body;
  static toObject(
    message: coop$rchain$casper$protocol$Body,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface coop$rchain$casper$protocol$IJustification {
  validator?: Uint8Array | null;
  latestBlockHash?: Uint8Array | null;
}

declare class coop$rchain$casper$protocol$Justification
  mixins coop$rchain$casper$protocol$IJustification {
  constructor(properties?: coop$rchain$casper$protocol$IJustification): this;
  validator: Uint8Array;
  latestBlockHash: Uint8Array;
  static create(
    properties?: coop$rchain$casper$protocol$IJustification
  ): coop$rchain$casper$protocol$Justification;
  static encode(
    message: coop$rchain$casper$protocol$IJustification,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IJustification,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$Justification;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$Justification;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): coop$rchain$casper$protocol$Justification;
  static toObject(
    message: coop$rchain$casper$protocol$Justification,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface coop$rchain$casper$protocol$IRChainState {
  preStateHash?: Uint8Array | null;
  postStateHash?: Uint8Array | null;
  bonds?: coop$rchain$casper$protocol$IBond[] | null;
  blockNumber?: number | Long | null;
}

declare class coop$rchain$casper$protocol$RChainState
  mixins coop$rchain$casper$protocol$IRChainState {
  constructor(properties?: coop$rchain$casper$protocol$IRChainState): this;
  preStateHash: Uint8Array;
  postStateHash: Uint8Array;
  bonds: coop$rchain$casper$protocol$IBond[];
  blockNumber: number | Long;
  static create(
    properties?: coop$rchain$casper$protocol$IRChainState
  ): coop$rchain$casper$protocol$RChainState;
  static encode(
    message: coop$rchain$casper$protocol$IRChainState,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IRChainState,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$RChainState;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$RChainState;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): coop$rchain$casper$protocol$RChainState;
  static toObject(
    message: coop$rchain$casper$protocol$RChainState,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface coop$rchain$casper$protocol$IEvent {
  produce?: coop$rchain$casper$protocol$IProduceEvent | null;
  consume?: coop$rchain$casper$protocol$IConsumeEvent | null;
  comm?: coop$rchain$casper$protocol$ICommEvent | null;
}

declare class coop$rchain$casper$protocol$Event
  mixins coop$rchain$casper$protocol$IEvent {
  constructor(properties?: coop$rchain$casper$protocol$IEvent): this;
  produce?: coop$rchain$casper$protocol$IProduceEvent | null;
  consume?: coop$rchain$casper$protocol$IConsumeEvent | null;
  comm?: coop$rchain$casper$protocol$ICommEvent | null;
  event_instance?: "produce" | "consume" | "comm";
  static create(
    properties?: coop$rchain$casper$protocol$IEvent
  ): coop$rchain$casper$protocol$Event;
  static encode(
    message: coop$rchain$casper$protocol$IEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$Event;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$Event;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): coop$rchain$casper$protocol$Event;
  static toObject(
    message: coop$rchain$casper$protocol$Event,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface coop$rchain$casper$protocol$IProduceEvent {
  channelsHash?: Uint8Array | null;
  hash?: Uint8Array | null;
  persistent?: boolean | null;
  sequenceNumber?: number | null;
}

declare class coop$rchain$casper$protocol$ProduceEvent
  mixins coop$rchain$casper$protocol$IProduceEvent {
  constructor(properties?: coop$rchain$casper$protocol$IProduceEvent): this;
  channelsHash: Uint8Array;
  hash: Uint8Array;
  persistent: boolean;
  sequenceNumber: number;
  static create(
    properties?: coop$rchain$casper$protocol$IProduceEvent
  ): coop$rchain$casper$protocol$ProduceEvent;
  static encode(
    message: coop$rchain$casper$protocol$IProduceEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IProduceEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$ProduceEvent;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$ProduceEvent;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): coop$rchain$casper$protocol$ProduceEvent;
  static toObject(
    message: coop$rchain$casper$protocol$ProduceEvent,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface coop$rchain$casper$protocol$IConsumeEvent {
  channelsHashes?: Uint8Array[] | null;
  hash?: Uint8Array | null;
  persistent?: boolean | null;
  sequenceNumber?: number | null;
}

declare class coop$rchain$casper$protocol$ConsumeEvent
  mixins coop$rchain$casper$protocol$IConsumeEvent {
  constructor(properties?: coop$rchain$casper$protocol$IConsumeEvent): this;
  channelsHashes: Uint8Array[];
  hash: Uint8Array;
  persistent: boolean;
  sequenceNumber: number;
  static create(
    properties?: coop$rchain$casper$protocol$IConsumeEvent
  ): coop$rchain$casper$protocol$ConsumeEvent;
  static encode(
    message: coop$rchain$casper$protocol$IConsumeEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IConsumeEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$ConsumeEvent;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$ConsumeEvent;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): coop$rchain$casper$protocol$ConsumeEvent;
  static toObject(
    message: coop$rchain$casper$protocol$ConsumeEvent,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface coop$rchain$casper$protocol$ICommEvent {
  consume?: coop$rchain$casper$protocol$IConsumeEvent | null;
  produces?: coop$rchain$casper$protocol$IProduceEvent[] | null;
}

declare class coop$rchain$casper$protocol$CommEvent
  mixins coop$rchain$casper$protocol$ICommEvent {
  constructor(properties?: coop$rchain$casper$protocol$ICommEvent): this;
  consume?: coop$rchain$casper$protocol$IConsumeEvent | null;
  produces: coop$rchain$casper$protocol$IProduceEvent[];
  static create(
    properties?: coop$rchain$casper$protocol$ICommEvent
  ): coop$rchain$casper$protocol$CommEvent;
  static encode(
    message: coop$rchain$casper$protocol$ICommEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$ICommEvent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$CommEvent;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$CommEvent;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): coop$rchain$casper$protocol$CommEvent;
  static toObject(
    message: coop$rchain$casper$protocol$CommEvent,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface coop$rchain$casper$protocol$IBond {
  validator?: Uint8Array | null;
  stake?: number | Long | null;
}

declare class coop$rchain$casper$protocol$Bond
  mixins coop$rchain$casper$protocol$IBond {
  constructor(properties?: coop$rchain$casper$protocol$IBond): this;
  validator: Uint8Array;
  stake: number | Long;
  static create(
    properties?: coop$rchain$casper$protocol$IBond
  ): coop$rchain$casper$protocol$Bond;
  static encode(
    message: coop$rchain$casper$protocol$IBond,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: coop$rchain$casper$protocol$IBond,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): coop$rchain$casper$protocol$Bond;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): coop$rchain$casper$protocol$Bond;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): coop$rchain$casper$protocol$Bond;
  static toObject(
    message: coop$rchain$casper$protocol$Bond,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
declare var scalapb: typeof npm$namespace$scalapb;

declare var npm$namespace$scalapb: {|
  MessageOptions: typeof scalapb$MessageOptions,
  FieldOptions: typeof scalapb$FieldOptions,
  EnumOptions: typeof scalapb$EnumOptions,
  EnumValueOptions: typeof scalapb$EnumValueOptions,
  OneofOptions: typeof scalapb$OneofOptions,
  ScalaPbOptions: typeof npm$namespace$scalapb$ScalaPbOptions
|};
declare interface scalapb$IScalaPbOptions {
  package_name?: string | null;
  flat_package?: boolean | null;
  import?: string[] | null;
  preamble?: string[] | null;
  single_file?: boolean | null;
  no_primitive_wrappers?: boolean | null;
  primitive_wrappers?: boolean | null;
  collection_type?: string | null;
  preserve_unknown_fields?: boolean | null;
  object_name?: string | null;
  scope?: $Values<typeof scalapb$ScalaPbOptions$OptionsScope> | null;
  lenses?: boolean | null;
  retain_source_code_info?: boolean | null;
  map_type?: string | null;
  test_only_no_java_conversions?: boolean | null;
}

declare class scalapb$ScalaPbOptions mixins scalapb$IScalaPbOptions {
  constructor(properties?: scalapb$IScalaPbOptions): this;
  package_name: string;
  flat_package: boolean;
  import: string[];
  preamble: string[];
  single_file: boolean;
  no_primitive_wrappers: boolean;
  primitive_wrappers: boolean;
  collection_type: string;
  preserve_unknown_fields: boolean;
  object_name: string;
  scope: $Values<typeof scalapb$ScalaPbOptions$OptionsScope>;
  lenses: boolean;
  retain_source_code_info: boolean;
  map_type: string;
  test_only_no_java_conversions: boolean;
  static create(properties?: scalapb$IScalaPbOptions): scalapb$ScalaPbOptions;
  static encode(
    message: scalapb$IScalaPbOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: scalapb$IScalaPbOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): scalapb$ScalaPbOptions;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): scalapb$ScalaPbOptions;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): scalapb$ScalaPbOptions;
  static toObject(
    message: scalapb$ScalaPbOptions,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare var npm$namespace$scalapb$ScalaPbOptions: {|
  OptionsScope: typeof scalapb$ScalaPbOptions$OptionsScope
|};

declare var scalapb$ScalaPbOptions$OptionsScope: {|
  +FILE: 0, // 0
  +PACKAGE: 1 // 1
|};

declare interface scalapb$IMessageOptions {
  extends?: string[] | null;
  companion_extends?: string[] | null;
  annotations?: string[] | null;
  type?: string | null;
  companion_annotations?: string[] | null;
  sealed_oneof_extends?: string[] | null;
}

declare class scalapb$MessageOptions mixins scalapb$IMessageOptions {
  constructor(properties?: scalapb$IMessageOptions): this;
  extends: string[];
  companion_extends: string[];
  annotations: string[];
  type: string;
  companion_annotations: string[];
  sealed_oneof_extends: string[];
  static create(properties?: scalapb$IMessageOptions): scalapb$MessageOptions;
  static encode(
    message: scalapb$IMessageOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: scalapb$IMessageOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): scalapb$MessageOptions;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): scalapb$MessageOptions;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): scalapb$MessageOptions;
  static toObject(
    message: scalapb$MessageOptions,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface scalapb$IFieldOptions {
  type?: string | null;
  scala_name?: string | null;
  collection_type?: string | null;
  key_type?: string | null;
  value_type?: string | null;
  annotations?: string[] | null;
  map_type?: string | null;
  no_box?: boolean | null;
}

declare class scalapb$FieldOptions mixins scalapb$IFieldOptions {
  constructor(properties?: scalapb$IFieldOptions): this;
  type: string;
  scala_name: string;
  collection_type: string;
  key_type: string;
  value_type: string;
  annotations: string[];
  map_type: string;
  no_box: boolean;
  static create(properties?: scalapb$IFieldOptions): scalapb$FieldOptions;
  static encode(
    message: scalapb$IFieldOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: scalapb$IFieldOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): scalapb$FieldOptions;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): scalapb$FieldOptions;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): scalapb$FieldOptions;
  static toObject(
    message: scalapb$FieldOptions,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface scalapb$IEnumOptions {
  extends?: string[] | null;
  companion_extends?: string[] | null;
  type?: string | null;
}

declare class scalapb$EnumOptions mixins scalapb$IEnumOptions {
  constructor(properties?: scalapb$IEnumOptions): this;
  extends: string[];
  companion_extends: string[];
  type: string;
  static create(properties?: scalapb$IEnumOptions): scalapb$EnumOptions;
  static encode(
    message: scalapb$IEnumOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: scalapb$IEnumOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): scalapb$EnumOptions;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): scalapb$EnumOptions;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): scalapb$EnumOptions;
  static toObject(
    message: scalapb$EnumOptions,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface scalapb$IEnumValueOptions {
  extends?: string[] | null;
}

declare class scalapb$EnumValueOptions mixins scalapb$IEnumValueOptions {
  constructor(properties?: scalapb$IEnumValueOptions): this;
  extends: string[];
  static create(
    properties?: scalapb$IEnumValueOptions
  ): scalapb$EnumValueOptions;
  static encode(
    message: scalapb$IEnumValueOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: scalapb$IEnumValueOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): scalapb$EnumValueOptions;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): scalapb$EnumValueOptions;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): scalapb$EnumValueOptions;
  static toObject(
    message: scalapb$EnumValueOptions,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface scalapb$IOneofOptions {
  extends?: string[] | null;
}

declare class scalapb$OneofOptions mixins scalapb$IOneofOptions {
  constructor(properties?: scalapb$IOneofOptions): this;
  extends: string[];
  static create(properties?: scalapb$IOneofOptions): scalapb$OneofOptions;
  static encode(
    message: scalapb$IOneofOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: scalapb$IOneofOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): scalapb$OneofOptions;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): scalapb$OneofOptions;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): scalapb$OneofOptions;
  static toObject(
    message: scalapb$OneofOptions,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IPar {
  sends?: ISend[] | null;
  receives?: IReceive[] | null;
  news?: INew[] | null;
  exprs?: IExpr[] | null;
  matches?: IMatch[] | null;
  unforgeables?: IGUnforgeable[] | null;
  bundles?: IBundle[] | null;
  connectives?: IConnective[] | null;
  locallyFree?: Uint8Array | null;
  connective_used?: boolean | null;
}
declare export class Par mixins IPar {
  constructor(properties?: IPar): this;
  sends: ISend[];
  receives: IReceive[];
  news: INew[];
  exprs: IExpr[];
  matches: IMatch[];
  unforgeables: IGUnforgeable[];
  bundles: IBundle[];
  connectives: IConnective[];
  locallyFree: Uint8Array;
  connective_used: boolean;
  static create(properties?: IPar): Par;
  static encode(message: IPar, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IPar,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): Par;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Par;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): Par;
  static toObject(
    message: Par,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface ITaggedContinuation {
  par_body?: IParWithRandom | null;
  scala_body_ref?: number | Long | null;
}
declare export class TaggedContinuation mixins ITaggedContinuation {
  constructor(properties?: ITaggedContinuation): this;
  par_body?: IParWithRandom | null;
  scala_body_ref: number | Long;
  tagged_cont?: "par_body" | "scala_body_ref";
  static create(properties?: ITaggedContinuation): TaggedContinuation;
  static encode(
    message: ITaggedContinuation,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: ITaggedContinuation,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): TaggedContinuation;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): TaggedContinuation;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): TaggedContinuation;
  static toObject(
    message: TaggedContinuation,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IParWithRandom {
  body?: IPar | null;
  randomState?: Uint8Array | null;
}
declare export class ParWithRandom mixins IParWithRandom {
  constructor(properties?: IParWithRandom): this;
  body?: IPar | null;
  randomState: Uint8Array;
  static create(properties?: IParWithRandom): ParWithRandom;
  static encode(
    message: IParWithRandom,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IParWithRandom,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): ParWithRandom;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ParWithRandom;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): ParWithRandom;
  static toObject(
    message: ParWithRandom,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IPCost {
  cost?: number | Long | null;
}
declare export class PCost mixins IPCost {
  constructor(properties?: IPCost): this;
  cost: number | Long;
  static create(properties?: IPCost): PCost;
  static encode(message: IPCost, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IPCost,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): PCost;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): PCost;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): PCost;
  static toObject(
    message: PCost,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IListParWithRandom {
  pars?: IPar[] | null;
  randomState?: Uint8Array | null;
}
declare export class ListParWithRandom mixins IListParWithRandom {
  constructor(properties?: IListParWithRandom): this;
  pars: IPar[];
  randomState: Uint8Array;
  static create(properties?: IListParWithRandom): ListParWithRandom;
  static encode(
    message: IListParWithRandom,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IListParWithRandom,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): ListParWithRandom;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): ListParWithRandom;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): ListParWithRandom;
  static toObject(
    message: ListParWithRandom,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IVar {
  bound_var?: number | null;
  free_var?: number | null;
  wildcard?: Var$IWildcardMsg | null;
}
declare export class Var mixins IVar {
  constructor(properties?: IVar): this;
  bound_var: number;
  free_var: number;
  wildcard?: Var$IWildcardMsg | null;
  var_instance?: "bound_var" | "free_var" | "wildcard";
  static create(properties?: IVar): Var;
  static encode(message: IVar, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IVar,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): Var;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Var;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): Var;
  static toObject(
    message: Var,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
declare var Var: typeof npm$namespace$Var;

declare var npm$namespace$Var: {|
  WildcardMsg: typeof Var$WildcardMsg
|};
declare interface Var$IWildcardMsg {}

declare class Var$WildcardMsg mixins Var$IWildcardMsg {
  constructor(properties?: Var$IWildcardMsg): this;
  static create(properties?: Var$IWildcardMsg): Var$WildcardMsg;
  static encode(
    message: Var$IWildcardMsg,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: Var$IWildcardMsg,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): Var$WildcardMsg;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): Var$WildcardMsg;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): Var$WildcardMsg;
  static toObject(
    message: Var$WildcardMsg,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IBundle {
  body?: IPar | null;
  writeFlag?: boolean | null;
  readFlag?: boolean | null;
}
declare export class Bundle mixins IBundle {
  constructor(properties?: IBundle): this;
  body?: IPar | null;
  writeFlag: boolean;
  readFlag: boolean;
  static create(properties?: IBundle): Bundle;
  static encode(message: IBundle, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IBundle,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): Bundle;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Bundle;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): Bundle;
  static toObject(
    message: Bundle,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface ISend {
  chan?: IPar | null;
  data?: IPar[] | null;
  persistent?: boolean | null;
  locallyFree?: Uint8Array | null;
  connective_used?: boolean | null;
}
declare export class Send mixins ISend {
  constructor(properties?: ISend): this;
  chan?: IPar | null;
  data: IPar[];
  persistent: boolean;
  locallyFree: Uint8Array;
  connective_used: boolean;
  static create(properties?: ISend): Send;
  static encode(message: ISend, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: ISend,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): Send;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Send;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): Send;
  static toObject(
    message: Send,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IReceiveBind {
  patterns?: IPar[] | null;
  source?: IPar | null;
  remainder?: IVar | null;
  freeCount?: number | null;
}
declare export class ReceiveBind mixins IReceiveBind {
  constructor(properties?: IReceiveBind): this;
  patterns: IPar[];
  source?: IPar | null;
  remainder?: IVar | null;
  freeCount: number;
  static create(properties?: IReceiveBind): ReceiveBind;
  static encode(
    message: IReceiveBind,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IReceiveBind,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): ReceiveBind;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ReceiveBind;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): ReceiveBind;
  static toObject(
    message: ReceiveBind,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IBindPattern {
  patterns?: IPar[] | null;
  remainder?: IVar | null;
  freeCount?: number | null;
}
declare export class BindPattern mixins IBindPattern {
  constructor(properties?: IBindPattern): this;
  patterns: IPar[];
  remainder?: IVar | null;
  freeCount: number;
  static create(properties?: IBindPattern): BindPattern;
  static encode(
    message: IBindPattern,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IBindPattern,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): BindPattern;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): BindPattern;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): BindPattern;
  static toObject(
    message: BindPattern,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IListBindPatterns {
  patterns?: IBindPattern[] | null;
}
declare export class ListBindPatterns mixins IListBindPatterns {
  constructor(properties?: IListBindPatterns): this;
  patterns: IBindPattern[];
  static create(properties?: IListBindPatterns): ListBindPatterns;
  static encode(
    message: IListBindPatterns,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IListBindPatterns,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): ListBindPatterns;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): ListBindPatterns;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): ListBindPatterns;
  static toObject(
    message: ListBindPatterns,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IReceive {
  binds?: IReceiveBind[] | null;
  body?: IPar | null;
  persistent?: boolean | null;
  peek?: boolean | null;
  bindCount?: number | null;
  locallyFree?: Uint8Array | null;
  connective_used?: boolean | null;
}
declare export class Receive mixins IReceive {
  constructor(properties?: IReceive): this;
  binds: IReceiveBind[];
  body?: IPar | null;
  persistent: boolean;
  peek: boolean;
  bindCount: number;
  locallyFree: Uint8Array;
  connective_used: boolean;
  static create(properties?: IReceive): Receive;
  static encode(message: IReceive, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IReceive,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): Receive;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Receive;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): Receive;
  static toObject(
    message: Receive,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface INew {
  bindCount?: number | null;
  p?: IPar | null;
  uri?: string[] | null;
  deployId?: IDeployId | null;
  deployerId?: IDeployerId | null;
  locallyFree?: Uint8Array | null;
}
declare export class New mixins INew {
  constructor(properties?: INew): this;
  bindCount: number;
  p?: IPar | null;
  uri: string[];
  deployId?: IDeployId | null;
  deployerId?: IDeployerId | null;
  locallyFree: Uint8Array;
  static create(properties?: INew): New;
  static encode(message: INew, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: INew,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): New;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): New;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): New;
  static toObject(
    message: New,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IMatchCase {
  pattern?: IPar | null;
  source?: IPar | null;
  freeCount?: number | null;
}
declare export class MatchCase mixins IMatchCase {
  constructor(properties?: IMatchCase): this;
  pattern?: IPar | null;
  source?: IPar | null;
  freeCount: number;
  static create(properties?: IMatchCase): MatchCase;
  static encode(
    message: IMatchCase,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IMatchCase,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): MatchCase;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): MatchCase;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): MatchCase;
  static toObject(
    message: MatchCase,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IMatch {
  target?: IPar | null;
  cases?: IMatchCase[] | null;
  locallyFree?: Uint8Array | null;
  connective_used?: boolean | null;
}
declare export class Match mixins IMatch {
  constructor(properties?: IMatch): this;
  target?: IPar | null;
  cases: IMatchCase[];
  locallyFree: Uint8Array;
  connective_used: boolean;
  static create(properties?: IMatch): Match;
  static encode(message: IMatch, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IMatch,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): Match;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Match;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): Match;
  static toObject(
    message: Match,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IExpr {
  g_bool?: boolean | null;
  g_int?: number | Long | null;
  g_string?: string | null;
  g_uri?: string | null;
  g_byte_array?: Uint8Array | null;
  e_not_body?: IENot | null;
  e_neg_body?: IENeg | null;
  e_mult_body?: IEMult | null;
  e_div_body?: IEDiv | null;
  e_plus_body?: IEPlus | null;
  e_minus_body?: IEMinus | null;
  e_lt_body?: IELt | null;
  e_lte_body?: IELte | null;
  e_gt_body?: IEGt | null;
  e_gte_body?: IEGte | null;
  e_eq_body?: IEEq | null;
  e_neq_body?: IENeq | null;
  e_and_body?: IEAnd | null;
  e_or_body?: IEOr | null;
  e_var_body?: IEVar | null;
  e_list_body?: IEList | null;
  e_tuple_body?: IETuple | null;
  e_set_body?: IESet | null;
  e_map_body?: IEMap | null;
  e_method_body?: IEMethod | null;
  e_matches_body?: IEMatches | null;
  e_percent_percent_body?: IEPercentPercent | null;
  e_plus_plus_body?: IEPlusPlus | null;
  e_minus_minus_body?: IEMinusMinus | null;
  e_mod_body?: IEMod | null;
}
declare export class Expr mixins IExpr {
  constructor(properties?: IExpr): this;
  g_bool: boolean;
  g_int: number | Long;
  g_string: string;
  g_uri: string;
  g_byte_array: Uint8Array;
  e_not_body?: IENot | null;
  e_neg_body?: IENeg | null;
  e_mult_body?: IEMult | null;
  e_div_body?: IEDiv | null;
  e_plus_body?: IEPlus | null;
  e_minus_body?: IEMinus | null;
  e_lt_body?: IELt | null;
  e_lte_body?: IELte | null;
  e_gt_body?: IEGt | null;
  e_gte_body?: IEGte | null;
  e_eq_body?: IEEq | null;
  e_neq_body?: IENeq | null;
  e_and_body?: IEAnd | null;
  e_or_body?: IEOr | null;
  e_var_body?: IEVar | null;
  e_list_body?: IEList | null;
  e_tuple_body?: IETuple | null;
  e_set_body?: IESet | null;
  e_map_body?: IEMap | null;
  e_method_body?: IEMethod | null;
  e_matches_body?: IEMatches | null;
  e_percent_percent_body?: IEPercentPercent | null;
  e_plus_plus_body?: IEPlusPlus | null;
  e_minus_minus_body?: IEMinusMinus | null;
  e_mod_body?: IEMod | null;
  expr_instance?:
    | "g_bool"
    | "g_int"
    | "g_string"
    | "g_uri"
    | "g_byte_array"
    | "e_not_body"
    | "e_neg_body"
    | "e_mult_body"
    | "e_div_body"
    | "e_plus_body"
    | "e_minus_body"
    | "e_lt_body"
    | "e_lte_body"
    | "e_gt_body"
    | "e_gte_body"
    | "e_eq_body"
    | "e_neq_body"
    | "e_and_body"
    | "e_or_body"
    | "e_var_body"
    | "e_list_body"
    | "e_tuple_body"
    | "e_set_body"
    | "e_map_body"
    | "e_method_body"
    | "e_matches_body"
    | "e_percent_percent_body"
    | "e_plus_plus_body"
    | "e_minus_minus_body"
    | "e_mod_body";
  static create(properties?: IExpr): Expr;
  static encode(message: IExpr, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IExpr,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): Expr;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Expr;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): Expr;
  static toObject(
    message: Expr,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IEList {
  ps?: IPar[] | null;
  locallyFree?: Uint8Array | null;
  connective_used?: boolean | null;
  remainder?: IVar | null;
}
declare export class EList mixins IEList {
  constructor(properties?: IEList): this;
  ps: IPar[];
  locallyFree: Uint8Array;
  connective_used: boolean;
  remainder?: IVar | null;
  static create(properties?: IEList): EList;
  static encode(message: IEList, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEList,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EList;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EList;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): EList;
  static toObject(
    message: EList,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IETuple {
  ps?: IPar[] | null;
  locallyFree?: Uint8Array | null;
  connective_used?: boolean | null;
}
declare export class ETuple mixins IETuple {
  constructor(properties?: IETuple): this;
  ps: IPar[];
  locallyFree: Uint8Array;
  connective_used: boolean;
  static create(properties?: IETuple): ETuple;
  static encode(message: IETuple, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IETuple,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): ETuple;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ETuple;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): ETuple;
  static toObject(
    message: ETuple,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IESet {
  ps?: IPar[] | null;
  locallyFree?: Uint8Array | null;
  connective_used?: boolean | null;
  remainder?: IVar | null;
}
declare export class ESet mixins IESet {
  constructor(properties?: IESet): this;
  ps: IPar[];
  locallyFree: Uint8Array;
  connective_used: boolean;
  remainder?: IVar | null;
  static create(properties?: IESet): ESet;
  static encode(message: IESet, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IESet,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): ESet;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ESet;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): ESet;
  static toObject(
    message: ESet,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IEMap {
  kvs?: IKeyValuePair[] | null;
  locallyFree?: Uint8Array | null;
  connective_used?: boolean | null;
  remainder?: IVar | null;
}
declare export class EMap mixins IEMap {
  constructor(properties?: IEMap): this;
  kvs: IKeyValuePair[];
  locallyFree: Uint8Array;
  connective_used: boolean;
  remainder?: IVar | null;
  static create(properties?: IEMap): EMap;
  static encode(message: IEMap, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEMap,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EMap;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EMap;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): EMap;
  static toObject(
    message: EMap,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IEMethod {
  methodName?: string | null;
  target?: IPar | null;
  arguments?: IPar[] | null;
  locallyFree?: Uint8Array | null;
  connective_used?: boolean | null;
}
declare export class EMethod mixins IEMethod {
  constructor(properties?: IEMethod): this;
  methodName: string;
  target?: IPar | null;
  arguments: IPar[];
  locallyFree: Uint8Array;
  connective_used: boolean;
  static create(properties?: IEMethod): EMethod;
  static encode(message: IEMethod, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEMethod,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): EMethod;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EMethod;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): EMethod;
  static toObject(
    message: EMethod,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IKeyValuePair {
  key?: IPar | null;
  value?: IPar | null;
}
declare export class KeyValuePair mixins IKeyValuePair {
  constructor(properties?: IKeyValuePair): this;
  key?: IPar | null;
  value?: IPar | null;
  static create(properties?: IKeyValuePair): KeyValuePair;
  static encode(
    message: IKeyValuePair,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IKeyValuePair,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): KeyValuePair;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): KeyValuePair;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): KeyValuePair;
  static toObject(
    message: KeyValuePair,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IEVar {
  v?: IVar | null;
}
declare export class EVar mixins IEVar {
  constructor(properties?: IEVar): this;
  v?: IVar | null;
  static create(properties?: IEVar): EVar;
  static encode(message: IEVar, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEVar,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EVar;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EVar;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): EVar;
  static toObject(
    message: EVar,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IENot {
  p?: IPar | null;
}
declare export class ENot mixins IENot {
  constructor(properties?: IENot): this;
  p?: IPar | null;
  static create(properties?: IENot): ENot;
  static encode(message: IENot, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IENot,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): ENot;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ENot;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): ENot;
  static toObject(
    message: ENot,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IENeg {
  p?: IPar | null;
}
declare export class ENeg mixins IENeg {
  constructor(properties?: IENeg): this;
  p?: IPar | null;
  static create(properties?: IENeg): ENeg;
  static encode(message: IENeg, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IENeg,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): ENeg;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ENeg;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): ENeg;
  static toObject(
    message: ENeg,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IEMult {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EMult mixins IEMult {
  constructor(properties?: IEMult): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEMult): EMult;
  static encode(message: IEMult, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEMult,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EMult;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EMult;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): EMult;
  static toObject(
    message: EMult,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IEDiv {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EDiv mixins IEDiv {
  constructor(properties?: IEDiv): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEDiv): EDiv;
  static encode(message: IEDiv, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEDiv,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EDiv;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EDiv;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): EDiv;
  static toObject(
    message: EDiv,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IEMod {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EMod mixins IEMod {
  constructor(properties?: IEMod): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEMod): EMod;
  static encode(message: IEMod, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEMod,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EMod;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EMod;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): EMod;
  static toObject(
    message: EMod,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IEPlus {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EPlus mixins IEPlus {
  constructor(properties?: IEPlus): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEPlus): EPlus;
  static encode(message: IEPlus, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEPlus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EPlus;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EPlus;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): EPlus;
  static toObject(
    message: EPlus,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IEMinus {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EMinus mixins IEMinus {
  constructor(properties?: IEMinus): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEMinus): EMinus;
  static encode(message: IEMinus, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEMinus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EMinus;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EMinus;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): EMinus;
  static toObject(
    message: EMinus,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IELt {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class ELt mixins IELt {
  constructor(properties?: IELt): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IELt): ELt;
  static encode(message: IELt, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IELt,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): ELt;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ELt;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): ELt;
  static toObject(
    message: ELt,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IELte {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class ELte mixins IELte {
  constructor(properties?: IELte): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IELte): ELte;
  static encode(message: IELte, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IELte,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): ELte;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ELte;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): ELte;
  static toObject(
    message: ELte,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IEGt {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EGt mixins IEGt {
  constructor(properties?: IEGt): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEGt): EGt;
  static encode(message: IEGt, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEGt,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EGt;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EGt;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): EGt;
  static toObject(
    message: EGt,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IEGte {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EGte mixins IEGte {
  constructor(properties?: IEGte): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEGte): EGte;
  static encode(message: IEGte, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEGte,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EGte;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EGte;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): EGte;
  static toObject(
    message: EGte,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IEEq {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EEq mixins IEEq {
  constructor(properties?: IEEq): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEEq): EEq;
  static encode(message: IEEq, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEEq,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EEq;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EEq;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): EEq;
  static toObject(
    message: EEq,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IENeq {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class ENeq mixins IENeq {
  constructor(properties?: IENeq): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IENeq): ENeq;
  static encode(message: IENeq, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IENeq,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): ENeq;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ENeq;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): ENeq;
  static toObject(
    message: ENeq,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IEAnd {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EAnd mixins IEAnd {
  constructor(properties?: IEAnd): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEAnd): EAnd;
  static encode(message: IEAnd, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEAnd,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EAnd;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EAnd;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): EAnd;
  static toObject(
    message: EAnd,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IEOr {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EOr mixins IEOr {
  constructor(properties?: IEOr): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEOr): EOr;
  static encode(message: IEOr, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEOr,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): EOr;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EOr;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): EOr;
  static toObject(
    message: EOr,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IEMatches {
  target?: IPar | null;
  pattern?: IPar | null;
}
declare export class EMatches mixins IEMatches {
  constructor(properties?: IEMatches): this;
  target?: IPar | null;
  pattern?: IPar | null;
  static create(properties?: IEMatches): EMatches;
  static encode(
    message: IEMatches,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IEMatches,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): EMatches;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EMatches;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): EMatches;
  static toObject(
    message: EMatches,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IEPercentPercent {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EPercentPercent mixins IEPercentPercent {
  constructor(properties?: IEPercentPercent): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEPercentPercent): EPercentPercent;
  static encode(
    message: IEPercentPercent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IEPercentPercent,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): EPercentPercent;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): EPercentPercent;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): EPercentPercent;
  static toObject(
    message: EPercentPercent,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IEPlusPlus {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EPlusPlus mixins IEPlusPlus {
  constructor(properties?: IEPlusPlus): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEPlusPlus): EPlusPlus;
  static encode(
    message: IEPlusPlus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IEPlusPlus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): EPlusPlus;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EPlusPlus;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): EPlusPlus;
  static toObject(
    message: EPlusPlus,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IEMinusMinus {
  p1?: IPar | null;
  p2?: IPar | null;
}
declare export class EMinusMinus mixins IEMinusMinus {
  constructor(properties?: IEMinusMinus): this;
  p1?: IPar | null;
  p2?: IPar | null;
  static create(properties?: IEMinusMinus): EMinusMinus;
  static encode(
    message: IEMinusMinus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IEMinusMinus,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): EMinusMinus;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EMinusMinus;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): EMinusMinus;
  static toObject(
    message: EMinusMinus,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IConnective {
  conn_and_body?: IConnectiveBody | null;
  conn_or_body?: IConnectiveBody | null;
  conn_not_body?: IPar | null;
  var_ref_body?: IVarRef | null;
  conn_bool?: boolean | null;
  conn_int?: boolean | null;
  conn_string?: boolean | null;
  conn_uri?: boolean | null;
  conn_byte_array?: boolean | null;
}
declare export class Connective mixins IConnective {
  constructor(properties?: IConnective): this;
  conn_and_body?: IConnectiveBody | null;
  conn_or_body?: IConnectiveBody | null;
  conn_not_body?: IPar | null;
  var_ref_body?: IVarRef | null;
  conn_bool: boolean;
  conn_int: boolean;
  conn_string: boolean;
  conn_uri: boolean;
  conn_byte_array: boolean;
  connective_instance?:
    | "conn_and_body"
    | "conn_or_body"
    | "conn_not_body"
    | "var_ref_body"
    | "conn_bool"
    | "conn_int"
    | "conn_string"
    | "conn_uri"
    | "conn_byte_array";
  static create(properties?: IConnective): Connective;
  static encode(
    message: IConnective,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IConnective,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): Connective;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Connective;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): Connective;
  static toObject(
    message: Connective,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IVarRef {
  index?: number | null;
  depth?: number | null;
}
declare export class VarRef mixins IVarRef {
  constructor(properties?: IVarRef): this;
  index: number;
  depth: number;
  static create(properties?: IVarRef): VarRef;
  static encode(message: IVarRef, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IVarRef,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): VarRef;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): VarRef;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): VarRef;
  static toObject(
    message: VarRef,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IConnectiveBody {
  ps?: IPar[] | null;
}
declare export class ConnectiveBody mixins IConnectiveBody {
  constructor(properties?: IConnectiveBody): this;
  ps: IPar[];
  static create(properties?: IConnectiveBody): ConnectiveBody;
  static encode(
    message: IConnectiveBody,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IConnectiveBody,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): ConnectiveBody;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): ConnectiveBody;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): ConnectiveBody;
  static toObject(
    message: ConnectiveBody,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IDeployId {
  sig?: Uint8Array | null;
}
declare export class DeployId mixins IDeployId {
  constructor(properties?: IDeployId): this;
  sig: Uint8Array;
  static create(properties?: IDeployId): DeployId;
  static encode(
    message: IDeployId,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IDeployId,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): DeployId;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): DeployId;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): DeployId;
  static toObject(
    message: DeployId,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IDeployerId {
  publicKey?: Uint8Array | null;
}
declare export class DeployerId mixins IDeployerId {
  constructor(properties?: IDeployerId): this;
  publicKey: Uint8Array;
  static create(properties?: IDeployerId): DeployerId;
  static encode(
    message: IDeployerId,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IDeployerId,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): DeployerId;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): DeployerId;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): DeployerId;
  static toObject(
    message: DeployerId,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IGUnforgeable {
  g_private_body?: IGPrivate | null;
  g_deploy_id_body?: IGDeployId | null;
  g_deployer_id_body?: IGDeployerId | null;
}
declare export class GUnforgeable mixins IGUnforgeable {
  constructor(properties?: IGUnforgeable): this;
  g_private_body?: IGPrivate | null;
  g_deploy_id_body?: IGDeployId | null;
  g_deployer_id_body?: IGDeployerId | null;
  unf_instance?: "g_private_body" | "g_deploy_id_body" | "g_deployer_id_body";
  static create(properties?: IGUnforgeable): GUnforgeable;
  static encode(
    message: IGUnforgeable,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IGUnforgeable,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): GUnforgeable;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): GUnforgeable;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): GUnforgeable;
  static toObject(
    message: GUnforgeable,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IGPrivate {
  id?: Uint8Array | null;
}
declare export class GPrivate mixins IGPrivate {
  constructor(properties?: IGPrivate): this;
  id: Uint8Array;
  static create(properties?: IGPrivate): GPrivate;
  static encode(
    message: IGPrivate,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IGPrivate,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): GPrivate;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): GPrivate;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): GPrivate;
  static toObject(
    message: GPrivate,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IGDeployId {
  sig?: Uint8Array | null;
}
declare export class GDeployId mixins IGDeployId {
  constructor(properties?: IGDeployId): this;
  sig: Uint8Array;
  static create(properties?: IGDeployId): GDeployId;
  static encode(
    message: IGDeployId,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IGDeployId,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): GDeployId;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): GDeployId;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): GDeployId;
  static toObject(
    message: GDeployId,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IGDeployerId {
  publicKey?: Uint8Array | null;
}
declare export class GDeployerId mixins IGDeployerId {
  constructor(properties?: IGDeployerId): this;
  publicKey: Uint8Array;
  static create(properties?: IGDeployerId): GDeployerId;
  static encode(
    message: IGDeployerId,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IGDeployerId,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): GDeployerId;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): GDeployerId;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): GDeployerId;
  static toObject(
    message: GDeployerId,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IEitherAny {
  type_url?: string | null;
  value?: Uint8Array | null;
}
declare export class EitherAny mixins IEitherAny {
  constructor(properties?: IEitherAny): this;
  type_url: string;
  value: Uint8Array;
  static create(properties?: IEitherAny): EitherAny;
  static encode(
    message: IEitherAny,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IEitherAny,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): EitherAny;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EitherAny;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): EitherAny;
  static toObject(
    message: EitherAny,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IEitherError {
  messages?: string[] | null;
}
declare export class EitherError mixins IEitherError {
  constructor(properties?: IEitherError): this;
  messages: string[];
  static create(properties?: IEitherError): EitherError;
  static encode(
    message: IEitherError,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IEitherError,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): EitherError;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EitherError;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): EitherError;
  static toObject(
    message: EitherError,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IEitherSuccess {
  response?: IEitherAny | null;
}
declare export class EitherSuccess mixins IEitherSuccess {
  constructor(properties?: IEitherSuccess): this;
  response?: IEitherAny | null;
  static create(properties?: IEitherSuccess): EitherSuccess;
  static encode(
    message: IEitherSuccess,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: IEitherSuccess,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): EitherSuccess;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): EitherSuccess;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): EitherSuccess;
  static toObject(
    message: EitherSuccess,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
export interface IEither {
  error?: IEitherError | null;
  success?: IEitherSuccess | null;
}
declare export class Either mixins IEither {
  constructor(properties?: IEither): this;
  error?: IEitherError | null;
  success?: IEitherSuccess | null;
  content?: "error" | "success";
  static create(properties?: IEither): Either;
  static encode(message: IEither, writer?: $protobuf.Writer): $protobuf.Writer;
  static encodeDelimited(
    message: IEither,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(reader: $protobuf.Reader | Uint8Array, length?: number): Either;
  static decodeDelimited(reader: $protobuf.Reader | Uint8Array): Either;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): Either;
  static toObject(
    message: Either,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
declare var google: typeof npm$namespace$google;

declare var npm$namespace$google: {|
  protobuf: typeof npm$namespace$google$protobuf
|};

declare var npm$namespace$google$protobuf: {|
  Empty: typeof google$protobuf$Empty,
  FileDescriptorSet: typeof google$protobuf$FileDescriptorSet,
  FileDescriptorProto: typeof google$protobuf$FileDescriptorProto,
  OneofDescriptorProto: typeof google$protobuf$OneofDescriptorProto,
  EnumDescriptorProto: typeof google$protobuf$EnumDescriptorProto,
  EnumValueDescriptorProto: typeof google$protobuf$EnumValueDescriptorProto,
  ServiceDescriptorProto: typeof google$protobuf$ServiceDescriptorProto,
  MethodDescriptorProto: typeof google$protobuf$MethodDescriptorProto,
  MessageOptions: typeof google$protobuf$MessageOptions,
  OneofOptions: typeof google$protobuf$OneofOptions,
  EnumOptions: typeof google$protobuf$EnumOptions,
  EnumValueOptions: typeof google$protobuf$EnumValueOptions,
  ServiceOptions: typeof google$protobuf$ServiceOptions,
  MethodOptions: typeof google$protobuf$MethodOptions,
  Any: typeof google$protobuf$Any,
  DescriptorProto: typeof npm$namespace$google$protobuf$DescriptorProto,
  FieldDescriptorProto: typeof npm$namespace$google$protobuf$FieldDescriptorProto,
  FileOptions: typeof npm$namespace$google$protobuf$FileOptions,
  FieldOptions: typeof npm$namespace$google$protobuf$FieldOptions,
  UninterpretedOption: typeof npm$namespace$google$protobuf$UninterpretedOption,
  SourceCodeInfo: typeof npm$namespace$google$protobuf$SourceCodeInfo,
  GeneratedCodeInfo: typeof npm$namespace$google$protobuf$GeneratedCodeInfo
|};
declare interface google$protobuf$IEmpty {}

declare class google$protobuf$Empty mixins google$protobuf$IEmpty {
  constructor(properties?: google$protobuf$IEmpty): this;
  static create(properties?: google$protobuf$IEmpty): google$protobuf$Empty;
  static encode(
    message: google$protobuf$IEmpty,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$IEmpty,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$Empty;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$Empty;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$Empty;
  static toObject(
    message: google$protobuf$Empty,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface google$protobuf$IFileDescriptorSet {
  file?: google$protobuf$IFileDescriptorProto[] | null;
}

declare class google$protobuf$FileDescriptorSet
  mixins google$protobuf$IFileDescriptorSet {
  constructor(properties?: google$protobuf$IFileDescriptorSet): this;
  file: google$protobuf$IFileDescriptorProto[];
  static create(
    properties?: google$protobuf$IFileDescriptorSet
  ): google$protobuf$FileDescriptorSet;
  static encode(
    message: google$protobuf$IFileDescriptorSet,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$IFileDescriptorSet,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$FileDescriptorSet;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$FileDescriptorSet;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$FileDescriptorSet;
  static toObject(
    message: google$protobuf$FileDescriptorSet,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface google$protobuf$IFileDescriptorProto {
  name?: string | null;
  package?: string | null;
  dependency?: string[] | null;
  public_dependency?: number[] | null;
  weak_dependency?: number[] | null;
  message_type?: google$protobuf$IDescriptorProto[] | null;
  enum_type?: google$protobuf$IEnumDescriptorProto[] | null;
  service?: google$protobuf$IServiceDescriptorProto[] | null;
  extension?: google$protobuf$IFieldDescriptorProto[] | null;
  options?: google$protobuf$IFileOptions | null;
  source_code_info?: google$protobuf$ISourceCodeInfo | null;
  syntax?: string | null;
}

declare class google$protobuf$FileDescriptorProto
  mixins google$protobuf$IFileDescriptorProto {
  constructor(properties?: google$protobuf$IFileDescriptorProto): this;
  name: string;
  package: string;
  dependency: string[];
  public_dependency: number[];
  weak_dependency: number[];
  message_type: google$protobuf$IDescriptorProto[];
  enum_type: google$protobuf$IEnumDescriptorProto[];
  service: google$protobuf$IServiceDescriptorProto[];
  extension: google$protobuf$IFieldDescriptorProto[];
  options?: google$protobuf$IFileOptions | null;
  source_code_info?: google$protobuf$ISourceCodeInfo | null;
  syntax: string;
  static create(
    properties?: google$protobuf$IFileDescriptorProto
  ): google$protobuf$FileDescriptorProto;
  static encode(
    message: google$protobuf$IFileDescriptorProto,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$IFileDescriptorProto,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$FileDescriptorProto;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$FileDescriptorProto;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$FileDescriptorProto;
  static toObject(
    message: google$protobuf$FileDescriptorProto,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface google$protobuf$IDescriptorProto {
  name?: string | null;
  field?: google$protobuf$IFieldDescriptorProto[] | null;
  extension?: google$protobuf$IFieldDescriptorProto[] | null;
  nested_type?: google$protobuf$IDescriptorProto[] | null;
  enum_type?: google$protobuf$IEnumDescriptorProto[] | null;
  extension_range?: google$protobuf$DescriptorProto$IExtensionRange[] | null;
  oneof_decl?: google$protobuf$IOneofDescriptorProto[] | null;
  options?: google$protobuf$IMessageOptions | null;
  reserved_range?: google$protobuf$DescriptorProto$IReservedRange[] | null;
  reserved_name?: string[] | null;
}

declare class google$protobuf$DescriptorProto
  mixins google$protobuf$IDescriptorProto {
  constructor(properties?: google$protobuf$IDescriptorProto): this;
  name: string;
  field: google$protobuf$IFieldDescriptorProto[];
  extension: google$protobuf$IFieldDescriptorProto[];
  nested_type: google$protobuf$IDescriptorProto[];
  enum_type: google$protobuf$IEnumDescriptorProto[];
  extension_range: google$protobuf$DescriptorProto$IExtensionRange[];
  oneof_decl: google$protobuf$IOneofDescriptorProto[];
  options?: google$protobuf$IMessageOptions | null;
  reserved_range: google$protobuf$DescriptorProto$IReservedRange[];
  reserved_name: string[];
  static create(
    properties?: google$protobuf$IDescriptorProto
  ): google$protobuf$DescriptorProto;
  static encode(
    message: google$protobuf$IDescriptorProto,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$IDescriptorProto,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$DescriptorProto;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$DescriptorProto;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$DescriptorProto;
  static toObject(
    message: google$protobuf$DescriptorProto,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare var npm$namespace$google$protobuf$DescriptorProto: {|
  ExtensionRange: typeof google$protobuf$DescriptorProto$ExtensionRange,
  ReservedRange: typeof google$protobuf$DescriptorProto$ReservedRange
|};
declare interface google$protobuf$DescriptorProto$IExtensionRange {
  start?: number | null;
  end?: number | null;
}

declare class google$protobuf$DescriptorProto$ExtensionRange
  mixins google$protobuf$DescriptorProto$IExtensionRange {
  constructor(
    properties?: google$protobuf$DescriptorProto$IExtensionRange
  ): this;
  start: number;
  end: number;
  static create(
    properties?: google$protobuf$DescriptorProto$IExtensionRange
  ): google$protobuf$DescriptorProto$ExtensionRange;
  static encode(
    message: google$protobuf$DescriptorProto$IExtensionRange,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$DescriptorProto$IExtensionRange,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$DescriptorProto$ExtensionRange;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$DescriptorProto$ExtensionRange;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$DescriptorProto$ExtensionRange;
  static toObject(
    message: google$protobuf$DescriptorProto$ExtensionRange,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface google$protobuf$DescriptorProto$IReservedRange {
  start?: number | null;
  end?: number | null;
}

declare class google$protobuf$DescriptorProto$ReservedRange
  mixins google$protobuf$DescriptorProto$IReservedRange {
  constructor(
    properties?: google$protobuf$DescriptorProto$IReservedRange
  ): this;
  start: number;
  end: number;
  static create(
    properties?: google$protobuf$DescriptorProto$IReservedRange
  ): google$protobuf$DescriptorProto$ReservedRange;
  static encode(
    message: google$protobuf$DescriptorProto$IReservedRange,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$DescriptorProto$IReservedRange,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$DescriptorProto$ReservedRange;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$DescriptorProto$ReservedRange;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$DescriptorProto$ReservedRange;
  static toObject(
    message: google$protobuf$DescriptorProto$ReservedRange,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface google$protobuf$IFieldDescriptorProto {
  name?: string | null;
  number?: number | null;
  label?: $Values<typeof google$protobuf$FieldDescriptorProto$Label> | null;
  type?: $Values<typeof google$protobuf$FieldDescriptorProto$Type> | null;
  type_name?: string | null;
  extendee?: string | null;
  default_value?: string | null;
  oneof_index?: number | null;
  json_name?: string | null;
  options?: google$protobuf$IFieldOptions | null;
}

declare class google$protobuf$FieldDescriptorProto
  mixins google$protobuf$IFieldDescriptorProto {
  constructor(properties?: google$protobuf$IFieldDescriptorProto): this;
  name: string;
  number: number;
  label: $Values<typeof google$protobuf$FieldDescriptorProto$Label>;
  type: $Values<typeof google$protobuf$FieldDescriptorProto$Type>;
  type_name: string;
  extendee: string;
  default_value: string;
  oneof_index: number;
  json_name: string;
  options?: google$protobuf$IFieldOptions | null;
  static create(
    properties?: google$protobuf$IFieldDescriptorProto
  ): google$protobuf$FieldDescriptorProto;
  static encode(
    message: google$protobuf$IFieldDescriptorProto,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$IFieldDescriptorProto,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$FieldDescriptorProto;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$FieldDescriptorProto;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$FieldDescriptorProto;
  static toObject(
    message: google$protobuf$FieldDescriptorProto,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare var npm$namespace$google$protobuf$FieldDescriptorProto: {|
  Type: typeof google$protobuf$FieldDescriptorProto$Type,
  Label: typeof google$protobuf$FieldDescriptorProto$Label
|};

declare var google$protobuf$FieldDescriptorProto$Type: {|
  +TYPE_DOUBLE: 1, // 1
  +TYPE_FLOAT: 2, // 2
  +TYPE_INT64: 3, // 3
  +TYPE_UINT64: 4, // 4
  +TYPE_INT32: 5, // 5
  +TYPE_FIXED64: 6, // 6
  +TYPE_FIXED32: 7, // 7
  +TYPE_BOOL: 8, // 8
  +TYPE_STRING: 9, // 9
  +TYPE_GROUP: 10, // 10
  +TYPE_MESSAGE: 11, // 11
  +TYPE_BYTES: 12, // 12
  +TYPE_UINT32: 13, // 13
  +TYPE_ENUM: 14, // 14
  +TYPE_SFIXED32: 15, // 15
  +TYPE_SFIXED64: 16, // 16
  +TYPE_SINT32: 17, // 17
  +TYPE_SINT64: 18 // 18
|};

declare var google$protobuf$FieldDescriptorProto$Label: {|
  +LABEL_OPTIONAL: 1, // 1
  +LABEL_REQUIRED: 2, // 2
  +LABEL_REPEATED: 3 // 3
|};

declare interface google$protobuf$IOneofDescriptorProto {
  name?: string | null;
  options?: google$protobuf$IOneofOptions | null;
}

declare class google$protobuf$OneofDescriptorProto
  mixins google$protobuf$IOneofDescriptorProto {
  constructor(properties?: google$protobuf$IOneofDescriptorProto): this;
  name: string;
  options?: google$protobuf$IOneofOptions | null;
  static create(
    properties?: google$protobuf$IOneofDescriptorProto
  ): google$protobuf$OneofDescriptorProto;
  static encode(
    message: google$protobuf$IOneofDescriptorProto,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$IOneofDescriptorProto,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$OneofDescriptorProto;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$OneofDescriptorProto;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$OneofDescriptorProto;
  static toObject(
    message: google$protobuf$OneofDescriptorProto,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface google$protobuf$IEnumDescriptorProto {
  name?: string | null;
  value?: google$protobuf$IEnumValueDescriptorProto[] | null;
  options?: google$protobuf$IEnumOptions | null;
}

declare class google$protobuf$EnumDescriptorProto
  mixins google$protobuf$IEnumDescriptorProto {
  constructor(properties?: google$protobuf$IEnumDescriptorProto): this;
  name: string;
  value: google$protobuf$IEnumValueDescriptorProto[];
  options?: google$protobuf$IEnumOptions | null;
  static create(
    properties?: google$protobuf$IEnumDescriptorProto
  ): google$protobuf$EnumDescriptorProto;
  static encode(
    message: google$protobuf$IEnumDescriptorProto,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$IEnumDescriptorProto,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$EnumDescriptorProto;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$EnumDescriptorProto;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$EnumDescriptorProto;
  static toObject(
    message: google$protobuf$EnumDescriptorProto,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface google$protobuf$IEnumValueDescriptorProto {
  name?: string | null;
  number?: number | null;
  options?: google$protobuf$IEnumValueOptions | null;
}

declare class google$protobuf$EnumValueDescriptorProto
  mixins google$protobuf$IEnumValueDescriptorProto {
  constructor(properties?: google$protobuf$IEnumValueDescriptorProto): this;
  name: string;
  number: number;
  options?: google$protobuf$IEnumValueOptions | null;
  static create(
    properties?: google$protobuf$IEnumValueDescriptorProto
  ): google$protobuf$EnumValueDescriptorProto;
  static encode(
    message: google$protobuf$IEnumValueDescriptorProto,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$IEnumValueDescriptorProto,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$EnumValueDescriptorProto;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$EnumValueDescriptorProto;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$EnumValueDescriptorProto;
  static toObject(
    message: google$protobuf$EnumValueDescriptorProto,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface google$protobuf$IServiceDescriptorProto {
  name?: string | null;
  method?: google$protobuf$IMethodDescriptorProto[] | null;
  options?: google$protobuf$IServiceOptions | null;
}

declare class google$protobuf$ServiceDescriptorProto
  mixins google$protobuf$IServiceDescriptorProto {
  constructor(properties?: google$protobuf$IServiceDescriptorProto): this;
  name: string;
  method: google$protobuf$IMethodDescriptorProto[];
  options?: google$protobuf$IServiceOptions | null;
  static create(
    properties?: google$protobuf$IServiceDescriptorProto
  ): google$protobuf$ServiceDescriptorProto;
  static encode(
    message: google$protobuf$IServiceDescriptorProto,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$IServiceDescriptorProto,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$ServiceDescriptorProto;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$ServiceDescriptorProto;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$ServiceDescriptorProto;
  static toObject(
    message: google$protobuf$ServiceDescriptorProto,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface google$protobuf$IMethodDescriptorProto {
  name?: string | null;
  input_type?: string | null;
  output_type?: string | null;
  options?: google$protobuf$IMethodOptions | null;
  client_streaming?: boolean | null;
  server_streaming?: boolean | null;
}

declare class google$protobuf$MethodDescriptorProto
  mixins google$protobuf$IMethodDescriptorProto {
  constructor(properties?: google$protobuf$IMethodDescriptorProto): this;
  name: string;
  input_type: string;
  output_type: string;
  options?: google$protobuf$IMethodOptions | null;
  client_streaming: boolean;
  server_streaming: boolean;
  static create(
    properties?: google$protobuf$IMethodDescriptorProto
  ): google$protobuf$MethodDescriptorProto;
  static encode(
    message: google$protobuf$IMethodDescriptorProto,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$IMethodDescriptorProto,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$MethodDescriptorProto;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$MethodDescriptorProto;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$MethodDescriptorProto;
  static toObject(
    message: google$protobuf$MethodDescriptorProto,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface google$protobuf$IFileOptions {
  java_package?: string | null;
  java_outer_classname?: string | null;
  java_multiple_files?: boolean | null;
  java_generate_equals_and_hash?: boolean | null;
  java_string_check_utf8?: boolean | null;
  optimize_for?: $Values<
    typeof google$protobuf$FileOptions$OptimizeMode
  > | null;
  go_package?: string | null;
  cc_generic_services?: boolean | null;
  java_generic_services?: boolean | null;
  py_generic_services?: boolean | null;
  deprecated?: boolean | null;
  cc_enable_arenas?: boolean | null;
  objc_class_prefix?: string | null;
  csharp_namespace?: string | null;
  uninterpreted_option?: google$protobuf$IUninterpretedOption[] | null;
  ".scalapb.options"?: scalapb$IScalaPbOptions | null;
}

declare class google$protobuf$FileOptions mixins google$protobuf$IFileOptions {
  constructor(properties?: google$protobuf$IFileOptions): this;
  java_package: string;
  java_outer_classname: string;
  java_multiple_files: boolean;
  java_generate_equals_and_hash: boolean;
  java_string_check_utf8: boolean;
  optimize_for: $Values<typeof google$protobuf$FileOptions$OptimizeMode>;
  go_package: string;
  cc_generic_services: boolean;
  java_generic_services: boolean;
  py_generic_services: boolean;
  deprecated: boolean;
  cc_enable_arenas: boolean;
  objc_class_prefix: string;
  csharp_namespace: string;
  uninterpreted_option: google$protobuf$IUninterpretedOption[];
  static create(
    properties?: google$protobuf$IFileOptions
  ): google$protobuf$FileOptions;
  static encode(
    message: google$protobuf$IFileOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$IFileOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$FileOptions;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$FileOptions;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$FileOptions;
  static toObject(
    message: google$protobuf$FileOptions,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare var npm$namespace$google$protobuf$FileOptions: {|
  OptimizeMode: typeof google$protobuf$FileOptions$OptimizeMode
|};

declare var google$protobuf$FileOptions$OptimizeMode: {|
  +SPEED: 1, // 1
  +CODE_SIZE: 2, // 2
  +LITE_RUNTIME: 3 // 3
|};

declare interface google$protobuf$IMessageOptions {
  message_set_wire_format?: boolean | null;
  no_standard_descriptor_accessor?: boolean | null;
  deprecated?: boolean | null;
  map_entry?: boolean | null;
  uninterpreted_option?: google$protobuf$IUninterpretedOption[] | null;
  ".scalapb.message"?: scalapb$IMessageOptions | null;
}

declare class google$protobuf$MessageOptions
  mixins google$protobuf$IMessageOptions {
  constructor(properties?: google$protobuf$IMessageOptions): this;
  message_set_wire_format: boolean;
  no_standard_descriptor_accessor: boolean;
  deprecated: boolean;
  map_entry: boolean;
  uninterpreted_option: google$protobuf$IUninterpretedOption[];
  static create(
    properties?: google$protobuf$IMessageOptions
  ): google$protobuf$MessageOptions;
  static encode(
    message: google$protobuf$IMessageOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$IMessageOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$MessageOptions;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$MessageOptions;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$MessageOptions;
  static toObject(
    message: google$protobuf$MessageOptions,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface google$protobuf$IFieldOptions {
  ctype?: $Values<typeof google$protobuf$FieldOptions$CType> | null;
  packed?: boolean | null;
  jstype?: $Values<typeof google$protobuf$FieldOptions$JSType> | null;
  lazy?: boolean | null;
  deprecated?: boolean | null;
  weak?: boolean | null;
  uninterpreted_option?: google$protobuf$IUninterpretedOption[] | null;
  ".scalapb.field"?: scalapb$IFieldOptions | null;
}

declare class google$protobuf$FieldOptions
  mixins google$protobuf$IFieldOptions {
  constructor(properties?: google$protobuf$IFieldOptions): this;
  ctype: $Values<typeof google$protobuf$FieldOptions$CType>;
  packed: boolean;
  jstype: $Values<typeof google$protobuf$FieldOptions$JSType>;
  lazy: boolean;
  deprecated: boolean;
  weak: boolean;
  uninterpreted_option: google$protobuf$IUninterpretedOption[];
  static create(
    properties?: google$protobuf$IFieldOptions
  ): google$protobuf$FieldOptions;
  static encode(
    message: google$protobuf$IFieldOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$IFieldOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$FieldOptions;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$FieldOptions;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$FieldOptions;
  static toObject(
    message: google$protobuf$FieldOptions,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare var npm$namespace$google$protobuf$FieldOptions: {|
  CType: typeof google$protobuf$FieldOptions$CType,
  JSType: typeof google$protobuf$FieldOptions$JSType
|};

declare var google$protobuf$FieldOptions$CType: {|
  +STRING: 0, // 0
  +CORD: 1, // 1
  +STRING_PIECE: 2 // 2
|};

declare var google$protobuf$FieldOptions$JSType: {|
  +JS_NORMAL: 0, // 0
  +JS_STRING: 1, // 1
  +JS_NUMBER: 2 // 2
|};

declare interface google$protobuf$IOneofOptions {
  uninterpreted_option?: google$protobuf$IUninterpretedOption[] | null;
  ".scalapb.oneof"?: scalapb$IOneofOptions | null;
}

declare class google$protobuf$OneofOptions
  mixins google$protobuf$IOneofOptions {
  constructor(properties?: google$protobuf$IOneofOptions): this;
  uninterpreted_option: google$protobuf$IUninterpretedOption[];
  static create(
    properties?: google$protobuf$IOneofOptions
  ): google$protobuf$OneofOptions;
  static encode(
    message: google$protobuf$IOneofOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$IOneofOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$OneofOptions;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$OneofOptions;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$OneofOptions;
  static toObject(
    message: google$protobuf$OneofOptions,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface google$protobuf$IEnumOptions {
  allow_alias?: boolean | null;
  deprecated?: boolean | null;
  uninterpreted_option?: google$protobuf$IUninterpretedOption[] | null;
  ".scalapb.enum_options"?: scalapb$IEnumOptions | null;
}

declare class google$protobuf$EnumOptions mixins google$protobuf$IEnumOptions {
  constructor(properties?: google$protobuf$IEnumOptions): this;
  allow_alias: boolean;
  deprecated: boolean;
  uninterpreted_option: google$protobuf$IUninterpretedOption[];
  static create(
    properties?: google$protobuf$IEnumOptions
  ): google$protobuf$EnumOptions;
  static encode(
    message: google$protobuf$IEnumOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$IEnumOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$EnumOptions;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$EnumOptions;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$EnumOptions;
  static toObject(
    message: google$protobuf$EnumOptions,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface google$protobuf$IEnumValueOptions {
  deprecated?: boolean | null;
  uninterpreted_option?: google$protobuf$IUninterpretedOption[] | null;
  ".scalapb.enum_value"?: scalapb$IEnumValueOptions | null;
}

declare class google$protobuf$EnumValueOptions
  mixins google$protobuf$IEnumValueOptions {
  constructor(properties?: google$protobuf$IEnumValueOptions): this;
  deprecated: boolean;
  uninterpreted_option: google$protobuf$IUninterpretedOption[];
  static create(
    properties?: google$protobuf$IEnumValueOptions
  ): google$protobuf$EnumValueOptions;
  static encode(
    message: google$protobuf$IEnumValueOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$IEnumValueOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$EnumValueOptions;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$EnumValueOptions;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$EnumValueOptions;
  static toObject(
    message: google$protobuf$EnumValueOptions,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface google$protobuf$IServiceOptions {
  deprecated?: boolean | null;
  uninterpreted_option?: google$protobuf$IUninterpretedOption[] | null;
}

declare class google$protobuf$ServiceOptions
  mixins google$protobuf$IServiceOptions {
  constructor(properties?: google$protobuf$IServiceOptions): this;
  deprecated: boolean;
  uninterpreted_option: google$protobuf$IUninterpretedOption[];
  static create(
    properties?: google$protobuf$IServiceOptions
  ): google$protobuf$ServiceOptions;
  static encode(
    message: google$protobuf$IServiceOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$IServiceOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$ServiceOptions;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$ServiceOptions;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$ServiceOptions;
  static toObject(
    message: google$protobuf$ServiceOptions,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface google$protobuf$IMethodOptions {
  deprecated?: boolean | null;
  uninterpreted_option?: google$protobuf$IUninterpretedOption[] | null;
}

declare class google$protobuf$MethodOptions
  mixins google$protobuf$IMethodOptions {
  constructor(properties?: google$protobuf$IMethodOptions): this;
  deprecated: boolean;
  uninterpreted_option: google$protobuf$IUninterpretedOption[];
  static create(
    properties?: google$protobuf$IMethodOptions
  ): google$protobuf$MethodOptions;
  static encode(
    message: google$protobuf$IMethodOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$IMethodOptions,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$MethodOptions;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$MethodOptions;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$MethodOptions;
  static toObject(
    message: google$protobuf$MethodOptions,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface google$protobuf$IUninterpretedOption {
  name?: google$protobuf$UninterpretedOption$INamePart[] | null;
  identifier_value?: string | null;
  positive_int_value?: number | Long | null;
  negative_int_value?: number | Long | null;
  double_value?: number | null;
  string_value?: Uint8Array | null;
  aggregate_value?: string | null;
}

declare class google$protobuf$UninterpretedOption
  mixins google$protobuf$IUninterpretedOption {
  constructor(properties?: google$protobuf$IUninterpretedOption): this;
  name: google$protobuf$UninterpretedOption$INamePart[];
  identifier_value: string;
  positive_int_value: number | Long;
  negative_int_value: number | Long;
  double_value: number;
  string_value: Uint8Array;
  aggregate_value: string;
  static create(
    properties?: google$protobuf$IUninterpretedOption
  ): google$protobuf$UninterpretedOption;
  static encode(
    message: google$protobuf$IUninterpretedOption,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$IUninterpretedOption,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$UninterpretedOption;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$UninterpretedOption;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$UninterpretedOption;
  static toObject(
    message: google$protobuf$UninterpretedOption,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare var npm$namespace$google$protobuf$UninterpretedOption: {|
  NamePart: typeof google$protobuf$UninterpretedOption$NamePart
|};
declare interface google$protobuf$UninterpretedOption$INamePart {
  name_part: string;
  is_extension: boolean;
}

declare class google$protobuf$UninterpretedOption$NamePart
  mixins google$protobuf$UninterpretedOption$INamePart {
  constructor(properties?: google$protobuf$UninterpretedOption$INamePart): this;
  name_part: string;
  is_extension: boolean;
  static create(
    properties?: google$protobuf$UninterpretedOption$INamePart
  ): google$protobuf$UninterpretedOption$NamePart;
  static encode(
    message: google$protobuf$UninterpretedOption$INamePart,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$UninterpretedOption$INamePart,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$UninterpretedOption$NamePart;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$UninterpretedOption$NamePart;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$UninterpretedOption$NamePart;
  static toObject(
    message: google$protobuf$UninterpretedOption$NamePart,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface google$protobuf$ISourceCodeInfo {
  location?: google$protobuf$SourceCodeInfo$ILocation[] | null;
}

declare class google$protobuf$SourceCodeInfo
  mixins google$protobuf$ISourceCodeInfo {
  constructor(properties?: google$protobuf$ISourceCodeInfo): this;
  location: google$protobuf$SourceCodeInfo$ILocation[];
  static create(
    properties?: google$protobuf$ISourceCodeInfo
  ): google$protobuf$SourceCodeInfo;
  static encode(
    message: google$protobuf$ISourceCodeInfo,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$ISourceCodeInfo,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$SourceCodeInfo;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$SourceCodeInfo;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$SourceCodeInfo;
  static toObject(
    message: google$protobuf$SourceCodeInfo,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare var npm$namespace$google$protobuf$SourceCodeInfo: {|
  Location: typeof google$protobuf$SourceCodeInfo$Location
|};
declare interface google$protobuf$SourceCodeInfo$ILocation {
  path?: number[] | null;
  span?: number[] | null;
  leading_comments?: string | null;
  trailing_comments?: string | null;
  leading_detached_comments?: string[] | null;
}

declare class google$protobuf$SourceCodeInfo$Location
  mixins google$protobuf$SourceCodeInfo$ILocation {
  constructor(properties?: google$protobuf$SourceCodeInfo$ILocation): this;
  path: number[];
  span: number[];
  leading_comments: string;
  trailing_comments: string;
  leading_detached_comments: string[];
  static create(
    properties?: google$protobuf$SourceCodeInfo$ILocation
  ): google$protobuf$SourceCodeInfo$Location;
  static encode(
    message: google$protobuf$SourceCodeInfo$ILocation,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$SourceCodeInfo$ILocation,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$SourceCodeInfo$Location;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$SourceCodeInfo$Location;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$SourceCodeInfo$Location;
  static toObject(
    message: google$protobuf$SourceCodeInfo$Location,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface google$protobuf$IGeneratedCodeInfo {
  annotation?: google$protobuf$GeneratedCodeInfo$IAnnotation[] | null;
}

declare class google$protobuf$GeneratedCodeInfo
  mixins google$protobuf$IGeneratedCodeInfo {
  constructor(properties?: google$protobuf$IGeneratedCodeInfo): this;
  annotation: google$protobuf$GeneratedCodeInfo$IAnnotation[];
  static create(
    properties?: google$protobuf$IGeneratedCodeInfo
  ): google$protobuf$GeneratedCodeInfo;
  static encode(
    message: google$protobuf$IGeneratedCodeInfo,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$IGeneratedCodeInfo,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$GeneratedCodeInfo;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$GeneratedCodeInfo;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$GeneratedCodeInfo;
  static toObject(
    message: google$protobuf$GeneratedCodeInfo,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare var npm$namespace$google$protobuf$GeneratedCodeInfo: {|
  Annotation: typeof google$protobuf$GeneratedCodeInfo$Annotation
|};
declare interface google$protobuf$GeneratedCodeInfo$IAnnotation {
  path?: number[] | null;
  source_file?: string | null;
  begin?: number | null;
  end?: number | null;
}

declare class google$protobuf$GeneratedCodeInfo$Annotation
  mixins google$protobuf$GeneratedCodeInfo$IAnnotation {
  constructor(properties?: google$protobuf$GeneratedCodeInfo$IAnnotation): this;
  path: number[];
  source_file: string;
  begin: number;
  end: number;
  static create(
    properties?: google$protobuf$GeneratedCodeInfo$IAnnotation
  ): google$protobuf$GeneratedCodeInfo$Annotation;
  static encode(
    message: google$protobuf$GeneratedCodeInfo$IAnnotation,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$GeneratedCodeInfo$IAnnotation,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$GeneratedCodeInfo$Annotation;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$GeneratedCodeInfo$Annotation;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$GeneratedCodeInfo$Annotation;
  static toObject(
    message: google$protobuf$GeneratedCodeInfo$Annotation,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}

declare interface google$protobuf$IAny {
  type_url?: string | null;
  value?: Uint8Array | null;
}

declare class google$protobuf$Any mixins google$protobuf$IAny {
  constructor(properties?: google$protobuf$IAny): this;
  type_url: string;
  value: Uint8Array;
  static create(properties?: google$protobuf$IAny): google$protobuf$Any;
  static encode(
    message: google$protobuf$IAny,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static encodeDelimited(
    message: google$protobuf$IAny,
    writer?: $protobuf.Writer
  ): $protobuf.Writer;
  static decode(
    reader: $protobuf.Reader | Uint8Array,
    length?: number
  ): google$protobuf$Any;
  static decodeDelimited(
    reader: $protobuf.Reader | Uint8Array
  ): google$protobuf$Any;
  static verify(message: {
    [k: string]: any,
    ...
  }): string | null;
  static fromObject(object: {
    [k: string]: any,
    ...
  }): google$protobuf$Any;
  static toObject(
    message: google$protobuf$Any,
    options?: $protobuf.IConversionOptions
  ): {
    [k: string]: any,
    ...
  };
  toJSON(): {
    [k: string]: any,
    ...
  };
}
