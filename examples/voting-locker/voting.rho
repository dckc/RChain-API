/**
 * Ballot -- Voting with delegation
 * 
 * See example / demo below.
 * 
 * Compare with Solidity contract:
 * https://solidity.readthedocs.io/en/develop/solidity-by-example.html#voting
 *
 *  Note delegation is a simple matter of sending your right to vote to another.
 */


new
  Ballot,
  export(`export:`),
  // export,
trace(`rho:io:stderr`),
stdout(`rho:io:stdout`),
insertArbitrary(`rho:registry:insertArbitrary`)
in {

  export!(bundle+{*Ballot}) |  // see loading.js and loader.rho

  // Set(hd, ...tail) is a pattern for a non-empty set.
  contract Ballot(@{proposalNames /\ Set(hd, ...tail)}, return) = {
    new chairperson, winningProposalName, voterWeightCh, votedCh, countCh, delegateCh in {
      return!(bundle+{*chairperson}, bundle+{*winningProposalName}) |

      countCh!({}) |       // proposal -> votes / weight

      contract chairperson(@"giveRightToVote", return) = {
        // "voter" is perhaps a mis-nomer. "votingRight" might be better.
        new voter, votedCh in {
          // rholang: debugging technique: trace inside each for() { ... }
          trace!({"chair": *chairperson, "gives right to vote": *voter}) |
          return!(bundle+{*voter}) |

          votedCh!(false) |

          contract voter(@"vote", @proposal, eject, ack) = {
            // trace!({"voter": *voter, "for": proposal}) |
            if(proposalNames.contains(proposal) == false) { eject!({"unknown proposal": proposal}) }
            else {
              for (@voted <- votedCh) {
                votedCh!(true) |
                if (voted) { eject!("already voted") }
                else {
                  for(@count <- countCh) {
                    trace!({"voter": *voter, "proposal": proposal}) |
                    countCh!(count.set(proposal, count.getOrElse(proposal, 0) + 1)) |
                    ack!(Nil)
                  }
                }
              }
            }
          }
        }
      } |

      contract winningProposalName(return) = {
        for(@count <- countCh) {
          countCh!(count) | // peek
          new loop in {
            contract loop(@best, @bestCount, @rest) = {
              match rest {
                Set() => { return!({ "winner": best, "tally": count}) }
                Set(hd, ...tail) => {
                  if (count.getOrElse(hd, 0) > bestCount) {
                    loop!(hd, count.getOrElse(hd, 0), tail)
                  } else {
                    loop!(best, bestCount, tail)
                  }
                }
              }
            } |
            match proposalNames {
              Set(hd, ...tail) => { loop!(hd, count.getOrElse(hd, 0), tail) }
            }
          }
        }
      }
    }
  }
  |
  // example / demo
  new bCh, v1Ch, v2Ch, v3Ch in {
    Ballot!(Set("Lincoln", "Douglas"), *bCh) |
    for (chairperson, winningProposalName <- bCh) {
      trace!({"Ballot returned": *chairperson}) |
      chairperson!("giveRightToVote", *v1Ch) |
      chairperson!("giveRightToVote", *v2Ch) |
      chairperson!("giveRightToVote", *v3Ch) |
      for(v1 <- v1Ch; v2 <- v2Ch; v3 <- v3Ch) {
        v1!("vote", "Douglas", *trace, *v1Ch) |
        v1!("vote", "Lincoln", *trace, *v1Ch) |
        v1!("vote", "Abe Lincoln", *trace, *v1Ch) |
        v2!("vote", "Lincoln", *trace, *v2Ch) |
        v3!("vote", "Lincoln", *trace, *v3Ch) |
        for(_ <- v1Ch; _ <- v2Ch; _ <- v3Ch) {
          // trace!("votes done") |
          winningProposalName!(*trace)
        }
      }
    }
  }
}
